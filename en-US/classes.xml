<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

<chapter id="pythonforyouandme-classes">
	<title>Class</title>
	<para>
		What is a <emphasis>class</emphasis>? In our daily life, we come across many objects which are similar kind or in words which are basically same. For example we can think about a car. There are different brands , color, look, style, parts, but basically they all are cars. All them of are made by different companies but with similar kind of components.
	</para>
	<para>
		We can say all of them are different instances of the <emphasis>class</emphasis> car. They all belongs to the car class. Every instance is known as an <emphasis>object</emphasis> in computer world. A <emphasis>class</emphasis> can contain variables or methods to access those variables.In Python everything is an <emphasis>object</emphasis>. Even if you create an integer, that is an object of the <emphasis>Integer class</emphasis>. In C++ this is different.
	</para>
	<section id="pythonforyouandme-Classes-firstclass">
		<title>Your first class</title>
		<para>
			Before writing your first class, you should know the syntax. We define a class in the following way..
		</para>
<screen>
<![CDATA[
class nameoftheclass:
    statement1
    statement2
    statement3
]]>
</screen>
		<para>
			in the statements you can write any python statement, you can define functions (which we call methods of a class).
		</para>
<screen>
<![CDATA[
>>> class MyClass:
...
Display all 180 possibilities? (y or n)
...     a = 90
...     b = 88
...
>>> p = MyClass()
>>> p
<__main__.MyClass instance at 0xb7c8aa6c>
]]>
</screen>
		<para>
			In the above example you can see first we are declaring a class called MyClass, writing some random statements inside that class. After the class definition, we are creating an <emphasis>object</emphasis> p of the <emphasis>class</emphasis> MyClass.If you do a dir on that...
		</para>
<screen>
<![CDATA[
>>> dir(p)
['__doc__', '__module__', 'a', 'b']
]]>
</screen>
		<para>
			You can see the variables <emphasis>a</emphasis> and <emphasis>b</emphasis> inside it.
		</para>
	</section>
	<section id="pythonforyouandme-Classes-initmethod">
		<title>__init__ method</title>
                <para>__init__ is a special method in python classes, it is the constructor method for a class. In the following example you can see how to use it</para>
<screen>
<![CDATA[
>>> class Student:
...   def __init__(self, name, branch, year):
...     self.name = name
...     self.branch = branch
...     self.year = year
...     print "A student object is created"
...   def getName(self):
...     return self.name
...   def setName(self, name):
...     self.name = name
...
]]>
</screen>
            <para>
            __init__ is called when ever an object of the class is constructed.That means when ever we will create a student object we will see the message "Creating a new student" in the prompt. You can see the first argument to the method is <emphasis>self</emphasis>. It is a special variable which points to the current object (like `this` in C++). The object is passed implicitly to every method available in it , but we have to get it explicitly in every method while writing the methods. Example shown below.
            </para>
<screen>
<![CDATA[
>>> std1 = Student()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() takes exactly 4 arguments (1 given)
>>> std1 = Student('Kushal','CSE','2005')
A student object is created
]]>
</screen>
            <para>
            In this example at first we tried to create a Student object with passing any argument and python interpreter complained that it takes exactly 4 arguments but received only one (self). Then we created an object with proper argument values and from the message printed, one can easily understand that <emphasis>__init__ </emphasis> method was called as the constructor method.
            </para>
            <para>
            Now we are going to call <emphasis>getName()</emphasis> and <emphasis>setName()</emphasis> methods.
            </para>
<screen>
<![CDATA[
>>> std1.getName()
'Kushal'
>>> std1.setName()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: setName() takes exactly 2 arguments (1 given)
>>> std1.setName('Shreyank Gupta')
>>> std1.getName()
'Shreyank Gupta'
]]>
</screen>
        <para>
        First we called getName on the object we created, then tried to call setName without any arguments and we got an error. Next we again called setName with argument 'Shreyank Gupta'. Now calling getName gives 'Shreyank Gupta' as the output.
        </para>
        </section>
	<section id="pythonforyouandme-Classes-inheritance">
		<title>Inheritance</title>
        <para>
        In general we human beings always know about inheritance. In programming it is almost the same. When a class inherits another class it inherits all features(like variables and methods) of the parent class. This helps in reusing codes. 
        </para>
        <para>
        In the next example we first create a class called Person and create two sub-classes Student and Teacher. As both of the classes are inherited from Person class they will have all methods of Person and will have new methods and variables for their own purpose.
        </para>
        </section>

	<section id="pythonforyouandme-Classes-student-teacher">
		<title>student_teacher.py</title>
<screen>
<![CDATA[
#!/usr/bin/env python

class Person:
    def __init__(self,name):
        self.name = name

    def getDetails(self):
        return self.name


class Student(Person):
    def __init__(self,name,branch,year):
        Person.__init__(self,name)
        self.branch = branch
        self.year = year

    def getDetails(self):
        return (self.name, self.branch, self.year)


class Teacher(Person):
    def __init__(self,name,papers):
        Person.__init__(self,name)
        self.papers = papers

    def getDetails(self):
        return (self.name, self.papers)


person1 = Person('Rahul')
student1 = Student('Kushal','CSE',2005)
teacher1 = Teacher('Prashad',['C','C++'])

print person1.getDetails()
print student1.getDetails()
print teacher1.getDetails()

]]>
</screen>
            <para>
            The output:
            </para>

<screen>
<![CDATA[
[kdas@kdas code]$ ./student_teacher.py
Rahul
('Kushal', 'CSE', 2005)
('Prashad', ['C', 'C++'])

]]>
</screen>
            <para>
            In this example you can see how we called the __init__ method of the class Person in both Studentà¦¾ and Teacher classes' __init__ method. We also reimplemented <emphasis>getDetails()</emphasis> method of Person class in both Student and Teacher class. So, when we are calling <emphasis>getDetails()</emphasis> method on the teacher1 object it returns based on the object itself (which is of teacher class) and when we call <emphasis>getDetails()</emphasis> on the student1 or person1 object it returns based on <emphasis>getDetails()</emphasis> method implemented in it's own class.
            </para>
</section>
	<section id="pythonforyouandme-Classes-multiple-inheritance">
		<title>Multiple Inheritance</title>
            <para>
            One class can inherit more than one classes. It gets access to all methods and variables of the parent classes. The general syntax is:
            </para>
<screen>
<![CDATA[
class MyClass(Parentclass1, Parentclass2,...):
    def __init__(self):
        Parentclass1.__init__(self)
        Parentclass2.__init__(self)
        ...
        ...
]]>
</screen>
        </section>
	<section id="pythonforyouandme-Classes-test">
		<title>Section 2 Test</title>
		<para>
			Test of a section
		</para>
	</section>

</chapter>

